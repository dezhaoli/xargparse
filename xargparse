#!/usr/bin/env -S bash
###########################################################
# @Author: dezhaoli@tencent.com
# @Date:   
# Please contact dezhaoli if you have any questions.
###########################################################


# Copyright 2009, The Android Open Source Project

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
###########################################################






# : ${XARGPARES_DEBUG:=false}
# XARGPARES_MAIN_EX_NAME='main-ex'
# XARGPARES_LABEL_NAME='label'
# XARGPARES_USE_BASH_ARGV


XARGPARES_VERSION=1.1.1


XARGPARES_REGEXP_SECTION2="
/[[:space:]]*(local[[:space:]]+)?([^[:space:]]*)=(.*[^[:space:]])[[:space:]]+#@[[:space:]]*(.*)/ {
    s//\4;dest=\2;default=\3;section=2;/;
    s/^[[:space:]]*([\"']?[a-zA-Z0-9_]+[\"']?)([[:space:]]*;.*)/pos=\1\2/

    s/^[[:space:]]*([\"']?--[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/long=\1\2/
    s/(.*;)[[:space:]]*([\"']?--[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/\1long=\2\3/

    s/^[[:space:]]*([\"']?-[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/short=\1\2/
    s/(.*;)[[:space:]]*([\"']?-[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/\1short=\2\3/

    s/;[[:space:]]*;/;/g
    s/^;//g
    p;
}
"
XARGPARES_REGEXP_SECTION5="
/[[:space:]]*(local[[:space:]]+)?([^[:space:]]*)=(.*[^[:space:]])[[:space:]]+#@[[:space:]]*(.*)/ {
    s//\4;dest=\2;default=\3;section=5;/;

    s/^[[:space:]]*([\"']?--[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/long=\1\2/
    s/(.*;)[[:space:]]*([\"']?--[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/\1long=\2\3/

    s/^[[:space:]]*([\"']?-[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/short=\1\2/
    s/(.*;)[[:space:]]*([\"']?-[a-zA-Z0-9_][-a-zA-Z0-9_]*[\"']?)([[:space:]]*;.*)/\1short=\2\3/

    s/;[[:space:]]*;/;/g
    s/^;//g
    p;
}
"


XARGPARES_Class_Function_Signature="
    func=
    arg=
    alia=
    flag=
    help=
"
XARGPARES_Class_Function_Body="
    dest=
    default=
    pos=
    short=
    long=
    action=
    choices=()
    nargs=
    help=
"
readonly \
        XARGPARES_VERSION \
        XARGPARES_REGEXP_SECTION2 \
        XARGPARES_REGEXP_SECTION5 \
        XARGPARES_Class_Function_Signature \
        XARGPARES_Class_Function_Body

# function _unset_xargparse_defines()
# {
#     unset -f have
#     unset \
#         XARGPARES_VERSION \
#         XARGPARES_REGEXP_SECTION2 \
#         XARGPARES_REGEXP_SECTION5 \
#         XARGPARES_Class_Function_Signature \
#         XARGPARES_Class_Function_Body

# }

function _xargparse_die()
{
    local msg=$1
    echo -e "error: $msg" >&2
    exit 1
}

function _xargparse_cmd_src()
{
    : ${XARGPARES_CMD_SRC:="$0"}
    [[ -r "$XARGPARES_CMD_SRC" ]] || _xargparse_die "target cmd [$XARGPARES_CMD_SRC] not found"

    XARGPARES_CMD_SRC="$(realpath "$XARGPARES_CMD_SRC")"   # convert to absolute path
}

function _xargparse_class_to_string()
{
    local class="$1"
    eval echo $(echo "$class" |sed -nE '/([a-z]+)=/s//\1=\"\$\1;\"/g ; /([a-z]+)=.*\(\)/s//\1=\"\(\$\{\1\[\*\]\}\);\"/g;p')
}

function _xargparse_print_usage()
{
    { local column_1="$1" column_2="$2" column_0="$3" ;}
    # echo "[${column_1}] [${column_2}]"
    printf "%3s %s%-80s %s \n" "${column_0}" "" "${column_1}" "${column_2:+#}${column_2}"
}


function _xargparse_usage_concise()
{
    shopt -qo xtrace && set +x && local XTRACE=true
    _xargparse_cmd_src
    echo -e "usage: $(basename $XARGPARES_CMD_SRC) <command> [-h] [optional arguments] [positional arguments]\ncommand:"
 # set -x
    local line=

    local eol=$'\n '

    local section=

    eval local ${XARGPARES_Class_Function_Signature}

    local is_last=false
    local opts_str=
    local poss_str=

    local last_func=
    local last_flag=
    local last_help=

    
    eval local ${XARGPARES_Class_Function_Body}
    function _reset_arg()
    {
        section=

        eval ${XARGPARES_Class_Function_Signature}

        eval ${XARGPARES_Class_Function_Body}
    }
    function print_last()
    {
        if $is_last; then
            is_last=false
            _xargparse_print_usage "${last_func}${opts_str:+ }${opts_str}${poss_str:+ }${poss_str}" "$last_help" "$last_flag"
        fi
    }

    while read line; do
        ${XARGPARES_DEBUG:-false} && echo "###line=[$line]"
        _reset_arg
        eval $line
        if ((section==1)); then
            ${XARGPARES_DEBUG:-false} && _xargparse_class_to_string "$XARGPARES_Class_Function_Signature"
            print_last
            is_last=true
            last_func="${alia:-$func}"
            last_help="$help"
            last_flag="$flag"
            opts_str=
            poss_str=
            
        elif ((section==2)); then
            ${XARGPARES_DEBUG:-false} && _xargparse_class_to_string "$XARGPARES_Class_Function_Body"
            local opt_str=
            local pos_str=
            if [[ -n "$short" && -n "$long" ]]; then
                opt_str="${short}|${long}"
            elif [[ -n "$short" ]]; then
                opt_str="$short"
            elif [[ -n "$long" ]]; then
                opt_str="$long"
            fi
            if [[ -n "$opt_str" ]]; then
                # if [[ -n "$default" ]]; then
                #     opt_str="$opt_str ($default)"
                # else
                    if [[ "$action" =~ store_.* ]]; then
                        opt_str="$opt_str"
                    elif [[ -n "$action" && "$action" != append ]]; then
                        _xargparse_die "unknown action \"$action\""
                    else
                        opt_str="$opt_str ${dest^^}"
                    fi
                # fi
                opts_str="${opts_str}[$opt_str]${opt_str:+ }"
            else
                if [[ "$nargs" == '+' ]]; then
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}... ($default)]"
                    else
                        pos_str="${pos:-$dest}..."
                    fi
                elif [[ "$nargs" == '*' ]]; then
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}... ($default)]"
                    else
                        pos_str="[${pos:-$dest}...]"
                    fi
                elif [[ "$nargs" == '?' ]]; then
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest} ($default)]"
                    else
                        pos_str="[${pos:-$dest}]"
                    fi
                else
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}]"
                    else
                        pos_str="${pos:-$dest}"
                    fi
                fi
                
                poss_str="${poss_str}$pos_str${pos_str:+ }"
                
            fi
            
        elif ((section==3)); then
            print_last
            if [[ "$alia" == "label" ]]; then
                echo "$help"
            fi
        elif ((section==4)); then
            print_last
            echo "$help"

        elif ((section==5)); then
            ${XARGPARES_DEBUG:-false} && _xargparse_class_to_string "$XARGPARES_Class_Function_Body"

            local opt_str=
            if [[ -n "$short" && -n "$long" ]]; then
                opt_str="${short}, ${long}"
            elif [[ -n "$short" ]]; then
                opt_str="$short"
            elif [[ -n "$long" ]]; then
                opt_str="$long"
            else
                _xargparse_print_usage "unsupported use of positional arguments in main-ex. line: $line"
            fi

            if [[ "$action" =~ store_.* ]]; then
                opt_str="$opt_str"
            elif [[ -n "$action" && "$action" != append ]]; then
                _xargparse_die "unknown action \"$action\""
            else
                opt_str="$opt_str ${dest^^}"
            fi

            if [[ -n "$default" ]]; then
                opt_str="$opt_str ($default)"
            fi

            _xargparse_print_usage "$opt_str" "$help"
            
            
        else
            _xargparse_die "unknown line: [$line]"
        fi
    done< <(< "$XARGPARES_CMD_SRC" sed  -nE "
    H
    /^##@@[[:space:]]*(alia='label'.*)/ {
        s//section=3;\1/
        s/;[[:space:]]*;/;/g
        p
    }
    x
    /^#@[[:space:]]*(.*)\nfunction [[:space:]]*([^[:space:]]*)\(\).*/ {
        s//section=1;func=\2;\1/
        p
        : loop_2
        n
        /^}/d
        ${XARGPARES_REGEXP_SECTION2}

        b loop_2
    }
    /^##@@[[:space:]]*(.*)\nfunction [[:space:]]*([^[:space:]]*)\(\).*/ {
        s//section=4;func=\2;\1/
        s/;[[:space:]]*;/;/g
        p
        : loop_5
        n
        /^}/d
        ${XARGPARES_REGEXP_SECTION5}

        b loop_5
    }

    ")
    print_last
    ${XTRACE:-false} && set -x
}


#@ help="auto find and parse bash arguages"
function ____()
{
    shopt -qo xtrace && set +x && local XTRACE=true

    if (($#==0)) && ${XARGPARES_USE_BASH_ARGV:-true}; then
        local offset=1
        local args=()
        local i=${#BASH_ARGV[@]}
        while (( i - offset > 0 )); do
            local arg="${BASH_ARGV[i - 1 - $offset]}"
            ((i=i-1))
            if [[ " ${XARGPARES_IGNORE_BASH_ARGV[*]} " =~ " $arg " ]]; then # TODO: remove this ugly code
                continue
            fi
            args[${#args[@]}]="$arg"
        done
        set -- "${args[@]}"
    fi

    parse_args "$@"

    ${XTRACE:-false} && set -x
}

#@ help="parse bash arguages, like getops"
function parse_args(){
    shopt -qo xtrace && set +x && local XTRACE=true
    _xargparse_cmd_src

    local func=""
    for func in "${FUNCNAME[@]}"; do
        if [[ "$func" != "parse_args" && "$func" != "____" ]]; then
            break
        fi
    done

    local -A s_optspecs
    local -A l_optspecs
    local p_argspecs=()

    local line=


    eval local ${XARGPARES_Class_Function_Body}

    function _reset_arg()
    {
        eval ${XARGPARES_Class_Function_Body}
    }
    function _parse_line()
    {
        if [[ -z "$line" ]]; then
            return 1
        fi
        eval $line
    }


    function _func_usage()
    {

        local opts_str="\n$(_xargparse_print_usage "-h, --help" "show this help message and exit")"
        local poss_str=
        while read line; do
            ${XARGPARES_DEBUG:-false} &&  echo "##line=[$line]"
            _reset_arg
            _parse_line
            ${XARGPARES_DEBUG:-false} && _xargparse_class_to_string "$XARGPARES_Class_Function_Body"

            local opt_str=
            local pos_str=
            local choices_str="${choices:+ \{}${choices[*]}${choices:+\}}"
            if [[ -n "$short" && -n "$long" ]]; then
                opt_str="${short}, ${long}"
            elif [[ -n "$short" ]]; then
                opt_str="$short"
            elif [[ -n "$long" ]]; then
                opt_str="$long"
            fi
            if [[ -n "$opt_str" ]]; then
                if [[ "$action" =~ store_.* ]]; then
                    opt_str="$opt_str"
                elif [[ -n "$action" && "$action" != append ]]; then
                    _xargparse_die "unknown action \"$action\""
                else
                    opt_str="$opt_str ${dest^^}"
                fi
                if [[ -n "$default" ]]; then
                    opt_str="$opt_str ($default)"
                fi

                opts_str="$opts_str\n$(_xargparse_print_usage "$opt_str" "$help")"
            else
                if [[ "$nargs" == '+' ]]; then
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}...${choices_str} ($default)]"
                    else
                        pos_str="${pos:-$dest}...${choices_str}"
                    fi
                elif [[ "$nargs" == '*' ]]; then
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}...${choices_str} ($default)]"
                    else
                        pos_str="[${pos:-$dest}...${choices_str}]"
                    fi
                elif [[ "$nargs" == '?' ]]; then
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}${choices_str} ($default)]"
                    else
                        pos_str="[${pos:-$dest}${choices_str}]"
                    fi
                else
                    if [[ -n "$default" ]]; then
                        pos_str="[${pos:-$dest}${choices_str} ($default)]"
                    else
                        pos_str="${pos:-$dest}${choices_str}"
                    fi
                fi
                
                poss_str="$poss_str\n$(_xargparse_print_usage "$pos_str" "$help")"
                
            fi


        done< <(< "$XARGPARES_CMD_SRC" sed  -nE "
        /^function $func\(\)/,/^}/ { 
            ${XARGPARES_REGEXP_SECTION2}
        }")

        echo -e "usage: $(basename $XARGPARES_CMD_SRC) ${alia:-$func} [-h] [optional arguments] [positional arguments] 
${poss_str:+"positional arguments:"}${poss_str}${poss_str:+\n}
${opts_str:+"optional arguments:"}${opts_str}
"

    }

    function _die()
    {
        _func_usage >&2
        _xargparse_die "$1"
    }

    if [[ "$#" == 1 && ( "$1" == "-h" || "$1" == "-help" || "$1" == "--help" )  ]]; then
        _func_usage
        exit 0
    fi
    
    while read line; do
        ${XARGPARES_DEBUG:-false} && echo "#line=[$line]"
        _reset_arg
        _parse_line
        ${XARGPARES_DEBUG:-false} && _xargparse_class_to_string "$XARGPARES_Class_Function_Body"

        [[ -z "$short" && -z "$long" ]] && p_argspecs[${#p_argspecs[@]}]="$line"
        [[ -n "$short" ]] && s_optspecs["$short"]="$line"
        [[ -n "$long" ]] && l_optspecs["$long"]="$line"


    done< <(< "$XARGPARES_CMD_SRC" sed  -nE "
    /^function $func\(\)/,/^}/ { 
        ${XARGPARES_REGEXP_SECTION2}
    }")

    function _check_choice()
    {
        local c 
        if ((${#choices[@]})); then
            for c in "${choices[@]}"; do
                [[ "$c" == "${x_i_x}" ]] && return 0
            done
            return 1
        fi
        return 0
    }
    function _set_array_val()
    {
        _check_choice || _die "argument ${pos:-$dest}: invalid choice: '${x_i_x}' (choose from ${choices[*]})"
        eval "$dest+=( \"${x_i_x}\" )"
    }
    function _set_val()
    {
        _check_choice || _die "argument ${pos:-$dest}: invalid choice: '${x_i_x}' (choose from ${choices[*]})"
        printf -v "$dest" "%s" "${x_i_x}"
    }
# set -x
    
    # parse the argument here
    local is_force_pos=false
    local p_index=0
    while (( "$#" )); do
        local x_i_x="$1" # NOTE: be careful, the name should be complicated here to avoid conflict
        shift
        if [[ "${x_i_x}" == "--" ]]; then
            is_force_pos=true
            continue
        fi
        local line=
        _reset_arg
        if [[ "${x_i_x}" =~ ^-[a-zA-Z0-9_].*$ ]] && ! $is_force_pos; then                   # short
            line="${s_optspecs["${x_i_x}"]}"
        elif [[ "${x_i_x}" =~ ^--[a-zA-Z0-9_].*$ ]] && ! $is_force_pos; then                # long
            line="${l_optspecs["${x_i_x}"]}"
        else                                                                                # position
            ((p_index < ${#p_argspecs[@]})) || _die "unrecognized arguments: ${x_i_x}"
            line="${p_argspecs[$p_index]}"
            ((p_index++))
        fi
        ${XARGPARES_DEBUG:-false} && echo "set line=[$line]"
        _parse_line || _die "argument ${x_i_x}: missing definition"



        if [[ -z "$short" && -z "$long" ]]; then # positional argument
            if [[ "$nargs" == '+' || "$nargs" == '*' ]]; then
                _set_array_val
                while (( "$#" )); do
                    x_i_x="$1"
                    shift
                    if [[ "${x_i_x}" =~ ^--?[-a-zA-Z0-9_]*$ ]]; then
                        break
                    fi
                    _set_array_val
                done
            else
                _set_val
            fi
        else  # optional argument
            if [[ "$action" =~ store_.* ]];then
                x_i_x=${action##store_}
                _set_val
            elif [[ "$action" == append ]];then
                (($#)) || _die "argument ${x_i_x}: expected one argument"
                x_i_x="$1"
                shift
                _set_array_val
            elif [[ -n "$action" ]]; then
                _die "unknown action \"$action\""
            else
                (($#)) || _die "argument ${x_i_x}: expected one argument"
                x_i_x="$1"
                shift
                _set_val
            fi
        fi
    done

    while ((p_index < ${#p_argspecs[@]})); do
        _reset_arg
        line="${p_argspecs[$p_index]}"
        _parse_line
        if [[ "$nargs" == '*' || "$nargs" == '?' || -n "$default" ]]; then
            ((p_index++))
        else
            _die "the following arguments are required: ${pos:-$dest}"
        fi
        
    done

    unset -f _reset_arg _parse_line _func_usage _die _check_choice _set_array_val _set_val

    ${XTRACE:-false} && set -x
}



function main()
{
    shopt -qo xtrace && set +x && local XTRACE=true
    _xargparse_cmd_src

    XARGPARES_USE_BASH_ARGV=false
    eval local ${XARGPARES_Class_Function_Signature}
    # find main-ex function and call it
    {
        local args=("$@")
        
        while read line; do
            # echo "==>[$line]"
            eval ${XARGPARES_Class_Function_Signature}
            eval $line
            if [[ "main-ex" == "$alia" && -n "$func" ]]; then
                command -v "$func" >/dev/null 2>&1 || _xargparse_die "the function[$func] pointed to by alia[$alia] was not found"

                args=("$func" "${args[@]}")
                ${XARGPARES_DEBUG:-false} &&  echo "before: args=${args[*]}" 
                "${args[@]}"
                ${XARGPARES_DEBUG:-false} &&  echo "after: args=${args[@]}"
            fi
    
        done< <(< "$XARGPARES_CMD_SRC" sed  -nE "
        /^##@@[[:space:]]*(.*)/ {
            s//\1/
            p
        } 
        ")
    }

    # show usage
    if (( ${#args[@]} == 0 )); then
        _xargparse_usage_concise >&2
        exit 0
    fi

    # install bash-complete
    if [[ ${#args[@]} == 1 && "${args[0]}" == '____' ]]; then
        touch ~/".xargparse/bash_completion.d/$(basename "$XARGPARES_CMD_SRC")"
        (($? == 0 )) && echo "Registered to bash completion: ok" || echo "Registered to bash completion: fail"

    fi

    # find the real sub command function
    {
        # local args=("$@")
        while read line; do
            # echo "==>[$line]"
            eval ${XARGPARES_Class_Function_Signature}
            eval $line
            if [[ "${args[0]}" == "$alia" ]]; then
                args[0]="$func"
            fi
    
        done< <(< "$XARGPARES_CMD_SRC" sed  -nE "
        H
        x
        /^#@[[:space:]]*(.*)\nfunction [[:space:]]*([^[:space:]]*)\(\).*/ {
            s//func=\2;\1/
            p
        } 
        ")
    }

    ${XTRACE:-false} && set -x

    "${args[@]}"


}

# call ourself
if [[ ! "$0" =~ ^-.* &&  # case call from -bash
    "$(basename "$0")" == "$(basename "$BASH_SOURCE")" ]]; then
    echo "$(basename "$0") $XARGPARES_VERSION"
    _xargparse_usage_concise
fi

